# =============================================
# Sprint 3 Quick Wins - Complete Package
# Download this ONE file, then run it to create all other files
# =============================================

$ErrorActionPreference = "Stop"

Write-Host "=========================================" -ForegroundColor Cyan
Write-Host "Sprint 3 Quick Wins - Setup Package" -ForegroundColor Cyan
Write-Host "=========================================" -ForegroundColor Cyan
Write-Host ""

# Get project root (assumes you're running from project root)
$ProjectRoot = Get-Location
Write-Host "Project root: $ProjectRoot" -ForegroundColor Yellow
Write-Host ""

# Confirm with user
$confirm = Read-Host "This will create files in backend/scripts/ and update your app. Continue? (y/n)"
if ($confirm -ne 'y') {
    Write-Host "Cancelled." -ForegroundColor Red
    exit
}

# =============================================
# FILE 1: SQL Backup Script
# =============================================
Write-Host "[1/6] Creating backup_database.sql..." -ForegroundColor Green

$BackupSQL = @'
-- =============================================
-- Super-Flashcards Database Backup Script
-- =============================================
DECLARE @BackupPath NVARCHAR(500)
DECLARE @BackupFile NVARCHAR(500)
DECLARE @DatabaseName NVARCHAR(100) = 'LanguageLearning'
DECLARE @DateStamp NVARCHAR(50)

SET @DateStamp = CONVERT(NVARCHAR(50), GETDATE(), 112) + '_' + 
                 REPLACE(CONVERT(NVARCHAR(50), GETDATE(), 108), ':', '')

SET @BackupPath = 'C:\Backups\SuperFlashcards\'
SET @BackupFile = @BackupPath + @DatabaseName + '_' + @DateStamp + '.bak'

EXEC xp_create_subdir @BackupPath

PRINT 'Starting backup: ' + @DatabaseName
PRINT 'Backup file: ' + @BackupFile

BACKUP DATABASE @DatabaseName
TO DISK = @BackupFile
WITH 
    FORMAT,
    INIT,
    NAME = @DatabaseName + ' Full Backup',
    COMPRESSION,
    STATS = 10,
    CHECKSUM

PRINT 'Backup completed successfully!'

-- Cleanup old backups (>30 days)
DECLARE @CleanupCommand NVARCHAR(500)
SET @CleanupCommand = 'FORFILES /P "' + @BackupPath + '" /M "' + @DatabaseName + '_*.bak" /D -30 /C "cmd /c del @path"'
EXEC xp_cmdshell @CleanupCommand

PRINT 'Cleanup completed!'

-- Verify backup
SELECT TOP 1
    database_name AS 'Database',
    backup_finish_date AS 'Backup Completed',
    CAST(backup_size / 1024 / 1024 AS DECIMAL(10,2)) AS 'Size (MB)',
    CAST(compressed_backup_size / 1024 / 1024 AS DECIMAL(10,2)) AS 'Compressed Size (MB)'
FROM msdb.dbo.backupset
WHERE database_name = @DatabaseName
ORDER BY backup_finish_date DESC
'@

$BackupSQLPath = Join-Path $ProjectRoot "backend\scripts\backup_database.sql"
New-Item -ItemType Directory -Path (Split-Path $BackupSQLPath) -Force | Out-Null
$BackupSQL | Out-File -FilePath $BackupSQLPath -Encoding UTF8 -Force
Write-Host "  ✓ Created: $BackupSQLPath" -ForegroundColor Gray

# =============================================
# FILE 2: PowerShell Backup Setup
# =============================================
Write-Host "[2/6] Creating setup_backup.ps1..." -ForegroundColor Green

$SetupBackupPS = @'
$BackupDir = "C:\Backups\SuperFlashcards"
$ScriptPath = "$PSScriptRoot\backup_database.sql"
$ServerInstance = "localhost\SQLEXPRESS"
$DatabaseName = "LanguageLearning"

Write-Host "Setting up automated backups..." -ForegroundColor Cyan

# Create backup directory
if (-not (Test-Path $BackupDir)) {
    New-Item -ItemType Directory -Path $BackupDir -Force | Out-Null
    Write-Host "✓ Created backup directory" -ForegroundColor Green
}

# Enable xp_cmdshell
$EnableXpCmdShell = @"
EXEC sp_configure 'show advanced options', 1;
RECONFIGURE;
EXEC sp_configure 'xp_cmdshell', 1;
RECONFIGURE;
"@

try {
    Invoke-Sqlcmd -ServerInstance $ServerInstance -Query $EnableXpCmdShell -ErrorAction Stop
    Write-Host "✓ Enabled xp_cmdshell" -ForegroundColor Green
} catch {
    Write-Host "⚠ Warning: Could not enable xp_cmdshell (run as Administrator)" -ForegroundColor Yellow
}

# Test backup
Write-Host "Running test backup..." -ForegroundColor Yellow
try {
    Invoke-Sqlcmd -ServerInstance $ServerInstance -InputFile $ScriptPath -QueryTimeout 300
    Write-Host "✓ Test backup successful!" -ForegroundColor Green
} catch {
    Write-Host "✗ Backup test failed: $_" -ForegroundColor Red
    exit 1
}

# Create scheduled task
$TaskName = "SuperFlashcards-DailyBackup"
$ActionScript = "sqlcmd -S $ServerInstance -d master -i `"$ScriptPath`" -o `"$BackupDir\backup_log.txt`""
$ActionScriptPath = "$BackupDir\run_backup.bat"
$ActionScript | Out-File -FilePath $ActionScriptPath -Encoding ASCII -Force

$Action = New-ScheduledTaskAction -Execute "cmd.exe" -Argument "/c `"$ActionScriptPath`""
$Trigger = New-ScheduledTaskTrigger -Daily -At "02:00"
$Principal = New-ScheduledTaskPrincipal -UserId "$env:USERDOMAIN\$env:USERNAME" -LogonType S4U -RunLevel Highest
$Settings = New-ScheduledTaskSettingsSet -StartWhenAvailable -DontStopOnIdleEnd

try {
    $ExistingTask = Get-ScheduledTask -TaskName $TaskName -ErrorAction SilentlyContinue
    if ($ExistingTask) {
        Unregister-ScheduledTask -TaskName $TaskName -Confirm:$false
    }
    
    Register-ScheduledTask -TaskName $TaskName -Action $Action -Trigger $Trigger -Principal $Principal -Settings $Settings -Force | Out-Null
    Write-Host "✓ Scheduled task created (daily at 2 AM)" -ForegroundColor Green
} catch {
    Write-Host "⚠ Could not create scheduled task (run as Administrator)" -ForegroundColor Yellow
}

Write-Host "`n✅ Backup setup complete!" -ForegroundColor Green
Write-Host "Backups saved to: $BackupDir" -ForegroundColor Gray
'@

$SetupBackupPath = Join-Path $ProjectRoot "backend\scripts\setup_backup.ps1"
$SetupBackupPS | Out-File -FilePath $SetupBackupPath -Encoding UTF8 -Force
Write-Host "  ✓ Created: $SetupBackupPath" -ForegroundColor Gray

# =============================================
# FILE 3: Full-Text Search SQL Setup
# =============================================
Write-Host "[3/6] Creating setup_fulltext_search.sql..." -ForegroundColor Green

$SearchSQL = @'
USE [LanguageLearning]
GO

PRINT 'Setting up Full-Text Search...'

-- Create Full-Text Catalog
IF NOT EXISTS (SELECT * FROM sys.fulltext_catalogs WHERE name = 'FlashcardCatalog')
BEGIN
    CREATE FULLTEXT CATALOG FlashcardCatalog AS DEFAULT
    PRINT '✓ Created Full-Text Catalog'
END

-- Drop existing index if exists
IF EXISTS (SELECT * FROM sys.fulltext_indexes WHERE object_id = OBJECT_ID('dbo.flashcards'))
BEGIN
    DROP FULLTEXT INDEX ON dbo.flashcards
END

-- Create full-text index
CREATE FULLTEXT INDEX ON dbo.flashcards
(
    word LANGUAGE 1033,
    translation LANGUAGE 1033,
    pronunciation LANGUAGE 1033,
    etymology LANGUAGE 1033,
    example_sentences LANGUAGE 1033,
    related_words LANGUAGE 1033,
    notes LANGUAGE 1033
)
KEY INDEX PK__flashcar__3213E83F1234567
ON FlashcardCatalog
WITH CHANGE_TRACKING AUTO

PRINT '✓ Created Full-Text Index'

-- Populate index
ALTER FULLTEXT INDEX ON dbo.flashcards START FULL POPULATION
PRINT '✓ Index population started'

-- Test search
PRINT ''
PRINT 'Testing search...'
SELECT TOP 5 word, translation
FROM flashcards
WHERE CONTAINS((word, translation), 'friend OR love OR hello')

PRINT '✅ Full-Text Search setup complete!'
'@

$SearchSQLPath = Join-Path $ProjectRoot "backend\scripts\setup_fulltext_search.sql"
$SearchSQL | Out-File -FilePath $SearchSQLPath -Encoding UTF8 -Force
Write-Host "  ✓ Created: $SearchSQLPath" -ForegroundColor Gray

# =============================================
# FILE 4: Search Router (Python)
# =============================================
Write-Host "[4/6] Creating search.py..." -ForegroundColor Green

$SearchPy = @'
# backend/app/routers/search.py
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from sqlalchemy import text
from typing import Optional
from pydantic import BaseModel
from app.database import get_db

router = APIRouter(prefix="/api/search", tags=["search"])

class SearchResult(BaseModel):
    id: str
    word: str
    translation: str
    pronunciation: Optional[str] = None
    etymology: Optional[str] = None
    language_id: str
    language_name: Optional[str] = None
    rank: Optional[int] = None

@router.get("/flashcards")
async def search_flashcards(
    q: str = Query(..., min_length=1),
    language_id: Optional[str] = None,
    search_type: str = Query("simple", regex="^(simple|phrase|ranked|fuzzy)$"),
    limit: int = Query(50, ge=1, le=500),
    db: Session = Depends(get_db)
):
    """Search flashcards using full-text search"""
    import time
    start_time = time.time()
    
    try:
        clean_query = q.replace("'", "''")
        
        if search_type == "ranked":
            sql_query = text(f"""
                SELECT f.id, f.word, f.translation, f.pronunciation, f.etymology,
                       f.language_id, l.name as language_name, ft.[RANK] as rank
                FROM flashcards f
                INNER JOIN FREETEXTTABLE(flashcards, (word, translation, etymology), '{clean_query}') ft
                    ON f.id = ft.[KEY]
                LEFT JOIN languages l ON f.language_id = l.id
                WHERE 1=1 {f"AND f.language_id = '{language_id}'" if language_id else ""}
                ORDER BY ft.[RANK] DESC
                OFFSET 0 ROWS FETCH NEXT {limit} ROWS ONLY
            """)
        else:
            if search_type == "phrase":
                search_cond = f'CONTAINS((word, translation, etymology), \'"{clean_query}"\')'
            elif search_type == "fuzzy":
                search_cond = f'CONTAINS((word, translation, etymology), \'"{clean_query}*"\')'
            else:
                search_cond = f'CONTAINS((word, translation, etymology), \'{clean_query}\')'
            
            sql_query = text(f"""
                SELECT f.id, f.word, f.translation, f.pronunciation, f.etymology,
                       f.language_id, l.name as language_name
                FROM flashcards f
                LEFT JOIN languages l ON f.language_id = l.id
                WHERE {search_cond} {f"AND f.language_id = '{language_id}'" if language_id else ""}
                ORDER BY f.created_at DESC
                OFFSET 0 ROWS FETCH NEXT {limit} ROWS ONLY
            """)
        
        results = db.execute(sql_query).fetchall()
        search_time = (time.time() - start_time) * 1000
        
        return {
            "results": [dict(row._mapping) for row in results],
            "stats": {
                "query": q,
                "total_results": len(results),
                "search_time_ms": round(search_time, 2),
                "search_type": search_type
            }
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/suggest")
async def search_suggestions(
    q: str = Query(..., min_length=2),
    limit: int = Query(10, ge=1, le=20),
    db: Session = Depends(get_db)
):
    """Get search suggestions (autocomplete)"""
    clean_query = q.replace("'", "''")
    sql_query = text(f"""
        SELECT DISTINCT TOP {limit} word, translation, language_id
        FROM flashcards
        WHERE CONTAINS((word, translation), '"{clean_query}*"')
        ORDER BY word
    """)
    results = db.execute(sql_query).fetchall()
    return {"suggestions": [dict(row._mapping) for row in results]}
'@

$SearchPyPath = Join-Path $ProjectRoot "backend\app\routers\search.py"
New-Item -ItemType Directory -Path (Split-Path $SearchPyPath) -Force | Out-Null
$SearchPy | Out-File -FilePath $SearchPyPath -Encoding UTF8 -Force
Write-Host "  ✓ Created: $SearchPyPath" -ForegroundColor Gray

# =============================================
# FILE 5: Word Frequency Analyzer
# =============================================
Write-Host "[5/6] Creating analyze_word_frequency.py..." -ForegroundColor Green

$AnalyzerPy = @'
# backend/scripts/analyze_word_frequency.py
import re
from collections import Counter
from pathlib import Path
import csv
import argparse

try:
    from docx import Document
except ImportError:
    print("Please install python-docx: pip install python-docx")
    exit(1)

def analyze_docx(file_path, language="French"):
    """Extract word frequencies from .docx file"""
    print(f"Analyzing: {file_path}")
    
    doc = Document(file_path)
    all_text = []
    
    for para in doc.paragraphs:
        if para.text.strip():
            all_text.append(para.text.strip())
    
    for table in doc.tables:
        for row in table.rows:
            for cell in row.cells:
                if cell.text.strip():
                    all_text.append(cell.text.strip())
    
    # Extract words
    words = []
    for segment in all_text:
        if len(segment) > 50:  # Skip long explanations
            continue
        if any(h in segment for h in ['Étymologie', 'Contexte', 'Équivalent']):
            continue
        
        matches = re.findall(r'\b[a-zA-ZàâäæçéèêëïîôùûüÿœÀÂÄÆÇÉÈÊËÏÎÔÙÛÜŸŒ\-\']+\b', segment)
        for word in matches:
            if len(word) >= 3 and not word.isupper():
                words.append(word.lower())
    
    frequency = Counter(words)
    print(f"Found {len(frequency)} unique words")
    
    return frequency

def export_csv(frequency, output_file, language="French", min_freq=1, max_words=None):
    """Export to CSV"""
    filtered = {w: c for w, c in frequency.items() if c >= min_freq}
    sorted_words = sorted(filtered.items(), key=lambda x: x[1], reverse=True)
    
    if max_words:
        sorted_words = sorted_words[:max_words]
    
    with open(output_file, 'w', newline='', encoding='utf-8') as f:
        writer = csv.writer(f)
        writer.writerow(['word', 'frequency', 'language', 'status'])
        for word, count in sorted_words:
            writer.writerow([word, count, language, 'pending'])
    
    print(f"Exported {len(sorted_words)} words to {output_file}")

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Analyze word frequency")
    parser.add_argument('input_file', help='Input .docx file')
    parser.add_argument('-o', '--output', default='word_frequency.csv')
    parser.add_argument('--language', default='French')
    parser.add_argument('--min-freq', type=int, default=1)
    parser.add_argument('--max-words', type=int, default=None)
    
    args = parser.parse_args()
    
    freq = analyze_docx(args.input_file, args.language)
    export_csv(freq, args.output, args.language, args.min_freq, args.max_words)
    
    print(f"\nTop 10 words:")
    for word, count in freq.most_common(10):
        print(f"  {word}: {count}")
'@

$AnalyzerPath = Join-Path $ProjectRoot "backend\scripts\analyze_word_frequency.py"
$AnalyzerPy | Out-File -FilePath $AnalyzerPath -Encoding UTF8 -Force
Write-Host "  ✓ Created: $AnalyzerPath" -ForegroundColor Gray

# =============================================
# FILE 6: Instructions
# =============================================
Write-Host "[6/6] Creating SETUP_INSTRUCTIONS.md..." -ForegroundColor Green

$Instructions = @'
# Sprint 3 Quick Wins - Setup Instructions

## 1. Database Backup (5 minutes)

```powershell
# Run as Administrator
.\backend\scripts\setup_backup.ps1

# Verify
Get-ScheduledTask -TaskName "SuperFlashcards-DailyBackup"
Get-ChildItem C:\Backups\SuperFlashcards\
```

## 2. Full-Text Search (15 minutes)

```powershell
# Step 1: Run SQL setup
sqlcmd -S localhost\SQLEXPRESS -d LanguageLearning -i backend\scripts\setup_fulltext_search.sql

# Step 2: Register search router in backend/app/main.py
# Add these lines:
#   from app.routers import search
#   app.include_router(search.router)

# Step 3: Restart server
.\runui.ps1

# Step 4: Test in browser at http://localhost:8000
```

## 3. Word Frequency Analyzer (10 minutes)

```powershell
# Install requirement
pip install python-docx

# Export Google Doc as .docx, then:
python backend\scripts\analyze_word_frequency.py "your_doc.docx" -o words.csv

# Review words.csv and remove unwanted entries
```

## Next Steps

1. Set up backups (peace of mind!)
2. Implement search (find cards instantly)
3. Analyze your documents (prepare for batch import)

See the artifacts in Claude for detailed documentation!
'@

$InstructionsPath = Join-Path $ProjectRoot "SETUP_INSTRUCTIONS.md"
$Instructions | Out-File -FilePath $InstructionsPath -Encoding UTF8 -Force
Write-Host "  ✓ Created: $InstructionsPath" -ForegroundColor Gray

# =============================================
# Summary
# =============================================
Write-Host ""
Write-Host "=========================================" -ForegroundColor Green
Write-Host "✅ All files created successfully!" -ForegroundColor Green
Write-Host "=========================================" -ForegroundColor Green
Write-Host ""
Write-Host "Created files:" -ForegroundColor Yellow
Write-Host "  • backend\scripts\backup_database.sql"
Write-Host "  • backend\scripts\setup_backup.ps1"
Write-Host "  • backend\scripts\setup_fulltext_search.sql"
Write-Host "  • backend\app\routers\search.py"
Write-Host "  • backend\scripts\analyze_word_frequency.py"
Write-Host "  • SETUP_INSTRUCTIONS.md"
Write-Host ""
Write-Host "Next steps:" -ForegroundColor Cyan
Write-Host "  1. Read SETUP_INSTRUCTIONS.md"
Write-Host "  2. Run: .\backend\scripts\setup_backup.ps1 (as Administrator)"
Write-Host "  3. Run: sqlcmd -S localhost\SQLEXPRESS -d LanguageLearning -i backend\scripts\setup_fulltext_search.sql"
Write-Host "  4. Add search router to backend\app\main.py"
Write-Host ""
Write-Host "🚀 Ready to implement Sprint 3 Quick Wins!" -ForegroundColor Green
